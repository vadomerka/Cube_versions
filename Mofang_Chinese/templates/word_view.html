<!DOCTYPE html>
<html>
<head>
    <meta charset=utf-8>
    <title>Mofang Chinese</title>
    <link rel="stylesheet"
          href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"
          integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh"
          crossorigin="anonymous">
    <style>
        canvas { width: 100%; height: 100% }
        body {
          overflow: hidden;
          margin: 0;
        }
        .c-button {
            position: absolute;
            left:50%;
            top:50%   ;
            min-width: 50px;
            min-height: 50px;
            appearance: none;
            border: 0;
            border-radius: 5px;
            background: #4676d7;
            color: #fff;
          
            cursor: pointer;
            border-radius: 50%;
        }

        .c-button:hover {
          background: #1d49aa;
        }

        .my-btn {
            
        }
        .url-word-buttons {
        	display: flex;
		    flex-wrap: nowrap;
		    flex-direction: row;
		    align-content: center;
		    justify-content: space-between;
		    margin-top: 2vh;
        }
        .back-help-word-buttons {
    	    width: 100%;
		    display: flex;
		    flex-direction: row;
		    justify-content: space-between;
		    align-items: center;
        }
        .help-button {
        	width: 45px;
        	height: 45px;
    	    display: flex;
		    align-items: center;
		    justify-content: center;
		    flex-wrap: nowrap;
		    flex-direction: column;
        }
        .explanation-container {
		    width: 100%;
		    min-height: 100%;
		    background-color: rgba(0,0,0,0.5);
		    overflow: hidden;
		    position: fixed;
		    top: 0px;
		    display: flex;
		    flex-direction: row;
		    flex-wrap: nowrap;
		    align-items: center;
		    justify-content: center;
		}
		.explanation-content {
			background-color: #ffffff;
		    width: 75%;
		    height: 40vw;
		    display: flex;
		    align-items: center;
		    flex-wrap: nowrap;
		    flex-direction: column;
		}
        .all-buttons {
        	position: absolute;
			width: 100%;
			height: 100%;
			display: flex;
			justify-content: space-between;
			align-items: center;
			flex-direction: column;
			flex-wrap: nowrap;
        }
        .cube-tutorial {
        	width: 100%;
        }
        .image-explanation {
    	    width: 80%;
			margin: 1rem;
        }
        .text-explanation {
    	    display: flex;
			flex-direction: column;
		    margin-left: 1rem;
        }
        .explanation-body {
        	display: flex;
		    flex-direction: column;
		    flex-wrap: nowrap;
		    align-items: center;
		    justify-content: space-between;
		    align-content: center;
        }
        .cube-sides-explanation {
        	display: flex;
		    flex-direction: row;
		    flex-wrap: nowrap;
		    align-items: center;
		    justify-content: space-between;
		    align-content: center;
        }
        .explanation-header {
    	    display: flex;
		    flex-direction: column;
		    align-items: center;
        }
        .close-button {
    	    background: transparent;
			border: transparent;
			position: absolute;
        }
        .close-button-container {
	        display: flex;
		    flex-direction: row-reverse;
		    margin: 0.5rem 0rem 0.5rem 0.5rem;
        }
        .tutorial-button-container {
        	display: flex;
    		justify-content: center;
    		margin: 1rem;
        }
        .image-hint-explanation {
        	width: 60%;
			margin: 1rem;
        }
    </style>
</head>
<body>
<script src="https://threejs.org/build/three.min.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
<div class="all-buttons">
	<div class="top-word-buttons" style="width: 100%;">
		<div class="back-help-word-buttons" style="width: 100%;">
			<a href="{{ back_url }}" class="btn btn-primary my-btn"> Назад </a>
			<button id="help-button" class="btn btn-primary help-button">
				<svg xmlns="http://www.w3.org/2000/svg" width="21" height="21" fill="currentColor" class="bi bi-question-circle" viewBox="0 0 16 16">
				    <path d="M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"/>
				    <path d="M5.255 5.786a.237.237 0 0 0 .241.247h.825c.138 0 .248-.113.266-.25.09-.656.54-1.134 1.342-1.134.686 0 1.314.343 1.314 1.168 0 .635-.374.927-.965 1.371-.673.489-1.206 1.06-1.168 1.987l.003.217a.25.25 0 0 0 .25.246h.811a.25.25 0 0 0 .25-.25v-.105c0-.718.273-.927 1.01-1.486.609-.463 1.244-.977 1.244-2.056 0-1.511-1.276-2.241-2.673-2.241-1.267 0-2.655.59-2.75 2.286zm1.557 5.763c0 .533.425.927 1.01.927.609 0 1.028-.394 1.028-.927 0-.552-.42-.94-1.029-.94-.584 0-1.009.388-1.009.94z"/>
				</svg>
			</button>
		</div>
		<button style="left: 673px; top: 216px;" id="playButton" class="c-button">
		    <svg aria-hidden="true" focusable="false" viewBox="0 0 200 200">
		        <polygon points="67,57 67,157, 157,107" style="fill:lime;fill-rule:evenodd;"></polygon>
		    </svg>
		</button>
		<div style="display: none;">
			<img id="right_side_image" src="{{ image_name }}">
		</div>
		<div class="url-word-buttons">
			<div id="prev_url" style="visibility: {{ prev_button_visibility }};">
			    <a href="{{ prev_word_url }}" class="btn btn-primary my-btn"
			       style="top: 50px; left: 0px; {{ disabled_style }}"> Предыдущее слово </a>
			</div>
			<div id="next_url" style="visibility: {{ next_button_visibility }};">
			    <a href="{{ next_word_url }}" class="btn btn-primary my-btn" style="top: 50px; right: 0px">
			        Следующее слово </a>
			</div>
		</div>
	</div>
	<a id="trainer-button" href="{{ trainer_href }}" class="btn btn-primary my-btn" hidden style="margin-bottom: 17vh;">Перейти к тренажерам</a>
</div>
<div id="explanation-container" class="explanation-container" hidden=true>
	<div class="explanation-content">
		<div style="overflow: auto;">
			<div class="close-button-container">
				<button id="close-button" class="close-button">
					<svg xmlns="http://www.w3.org/2000/svg" height="50px" viewBox="0 0 329.26933 329" width="50px">
						<path fill="rgb(173, 173, 173, 0.5)" d="m194.800781 164.769531 128.210938-128.214843c8.34375-8.339844 8.34375-21.824219 0-30.164063-8.339844-8.339844-21.824219-8.339844-30.164063 0l-128.214844 128.214844-128.210937-128.214844c-8.34375-8.339844-21.824219-8.339844-30.164063 0-8.34375 8.339844-8.34375 21.824219 0 30.164063l128.210938 128.214843-128.210938 128.214844c-8.34375 8.339844-8.34375 21.824219 0 30.164063 4.15625 4.160156 9.621094 6.25 15.082032 6.25 5.460937 0 10.921875-2.089844 15.082031-6.25l128.210937-128.214844 128.214844 128.214844c4.160156 4.160156 9.621094 6.25 15.082032 6.25 5.460937 0 10.921874-2.089844 15.082031-6.25 8.34375-8.339844 8.34375-21.824219 0-30.164063zm0 0"></path>
					</svg>
				</button>
			</div>	
			<div class="explanation-header">
				<h1 style="text-align: -webkit-center;">Как управлять кубиком?</h1>
				<p>У нашего кубика есть 5 сторон</p>
			</div>
			<div class="explanation-body">
				<div class="cube-sides-explanation">
					<div class="image-explanation">
						<img class="cube-tutorial" src="/static/cube_tutorial.png">
					</div>
					<div class="text-explanation">
						<p>на передней стороне написан иероглиф слова</p>
						<p>на нижней стороне написан перевод слова</p>
						<p>на правой стороне написана транскрипция и картинка слова</p>
						<p>на левой стороне написано словосочетание с использованием слова</p>
						<p>на верхней стороне написан перевод словосочетания с использованием слова</p>
					</div>
				</div>
				<div class="text-explanation">
					<p>Если кубик повернут передней стороной к вам, то его можно повернуть во все 4 стороны</p>
					<p>Если кубик повернут правой или левой стороной к вам, то его можно повернуть на переднюю, верхнюю и нижнюю стороны</p>
					<p>Если кубик повернут верхней или нижней стороной к вам, то его можно повернуть только вниз или вверх, на сторону, откуда вы пришли</p>
				</div>
				<div class="cube-sides-explanation">
					<div class="image-hint-explanation">
						<img class="cube-tutorial" src="/static/hints_tutorial_white.png">
					</div>
					<div class="text-explanation">
						<p>Также на сторонах кубика есть зеленые полоски</p>
						<p>Они подсказывают можно ли повернуть в ту или иную сторону</p>
					</div>
				</div>
				<div class="cube-audio-explanation">
					<div class="explanation-header">
						<p>Над кубиком можно увидеть кнопку озвучивания</p>
					</div>
					<div class="tutorial-button-container">
						<button focusable="false" style="width: 50px;
													     height: 50px;
													     appearance: none;
													     border: 0;
													     background: #4676d7;
													     color: #fff;
													     cursor: pointer;
													     border-radius: 50%;">
						    <svg aria-hidden="true" focusable="false" viewBox="0 0 200 200">
					        	<polygon points="67,57 67,157, 157,107" style="fill:lime;fill-rule:evenodd;"></polygon>
					    	</svg>
						</button>
					</div>
					<div class="text-explanation">
						<p>При нажатии будет слышно аудио, соответствующее стороне кубика</p>
						<p>Если создатель слова его добавил</p>
					</div>
				</div>
			</div>
		</div>
	</div>	
</div>
<script src="js/three.js"></script>
<script src="/static/templates_js/cube_side_text.js"></script>
<script>
    var speed_of_rotation_x = speed_of_rotation_y = 0.1; // скорость поворота кубика
    var angle_of_rotation_x = 0;  // на сколько нужно повернуться по x
    var angle_of_rotation_y = 0;  // на сколько нужно повернуться по y
    var main_sound = "none";

    var camera_z = 2;
    var width = window.innerWidth;
    var height = window.innerHeight;
    var play_button_size = 50;

    var cube_scene_size = 1;
    var start_of_scene_z = 0.1;
    var size_of_scene = 90;
    var end_of_scene_z = 5;
    // для фиксирования нажатий на кубик
    var size_coef = (cube_scene_size / 2) / (camera_z - (cube_scene_size / 2));

    var half_cube_size = Math.round((height * size_coef) / 2);
    var cube_screen_cords = {"up left": [Math.round(width / 2) - half_cube_size, Math.round(height / 2) - half_cube_size],
                            "up right": [Math.round(width / 2) + half_cube_size, Math.round(height / 2) - half_cube_size],
                            "down left": [Math.round(width / 2) - half_cube_size, Math.round(height / 2) + half_cube_size],
                            "down right": [Math.round(width / 2) + half_cube_size, Math.round(height / 2) + half_cube_size]};
    var cube_sides_x = ["front", "right", "back", "left"];
    var cube_sides_y = ["x side", "up", "x side", "down"];
    var current_side_x = 0;
    var current_side_y = 0;

    var playButton = document.getElementById("playButton");
    playButton.addEventListener("click", onPlayButtonClick, false);
    playButton.style.left = Math.round(width / 2) - play_button_size / 2 + "px";
    playButton.style.top = Math.round(height / 2) - half_cube_size - play_button_size * 2 + "px";

    function onPlayButtonClick(event) {
        if (main_sound != "none"){
            if (main_sound.isPlaying){main_sound.stop();}
            else {
                main_sound.play();
            }
        }
    }

    function buttonsScreenUpdate(){
        playButton = document.getElementById("playButton");
        playButton.addEventListener("click", onPlayButtonClick, false);
        playButton.style.left = Math.round(width / 2) - play_button_size / 2 + "px";
        playButton.style.top = Math.round(height / 2) - half_cube_size - play_button_size * 2 + "px";
    }

    function screenUpdateCheck(){
        width = window.innerWidth;
        height = window.innerHeight;

        buttonsScreenUpdate();

        // without updating of the camara the cube proportions break
        camera = new THREE.PerspectiveCamera( size_of_scene, width / height, 0.1, 5 );  // camera perspective
        camera.position.z = camera_z;
        // without updating of the renderer the three.js window breaks
        renderer.setSize( width, height);  // cube lesson size on the screene
        renderer.setClearColor("#01131E");
        document.body.appendChild( renderer.domElement);
        renderer.render( scene, camera );

        scene.add( cube );

        // limit dots
        half_cube_size = Math.round((height * size_coef) / 2);
        cube_screen_cords = {"up left": [Math.round(width / 2) - half_cube_size, Math.round(height / 2) - half_cube_size],
                            "up right": [Math.round(width / 2) + half_cube_size, Math.round(height / 2) - half_cube_size],
                            "down left": [Math.round(width / 2) - half_cube_size, Math.round(height / 2) + half_cube_size],
                            "down right": [Math.round(width / 2) + half_cube_size, Math.round(height / 2) + half_cube_size]};
    }

    function changeSides(side, text_ang){
        geometry = new THREE.BoxGeometry( cube_scene_size, cube_scene_size, cube_scene_size );
        const loader = new THREE.TextureLoader();
        var filepath = "images/";
        if (side == "up") {
            if (text_ang == 90) {text_ang = 270;}
            else if (text_ang == 270) {text_ang = 90;}  // иначе слова вверх ногами
            materials[2] = new THREE.MeshBasicMaterial({map: cubeViewSideText(up_text, text_ang, up_color, "up")});
        }
        if (side == "down") {
            materials[3] = new THREE.MeshBasicMaterial({map: cubeViewSideText(down_text, text_ang, down_color, "down")});
        }
        old_rot_x = cube.rotation.x
        old_rot_y = cube.rotation.y
        old_rot_z = cube.rotation.z
        scene.remove(cube);
        //alert("Hy");
        cube = new THREE.Mesh(geometry, materials);
        cube.rotation.x = old_rot_x;
        cube.rotation.y = old_rot_y;
        cube.rotation.z = old_rot_z;
        scene.add( cube );
        // scene.overrideMaterial = new THREE.MeshBasicMaterial({map: loader.load(front_img)});
        // alert(front_img)
        // limit dots
        half_cube_size = Math.round((height * size_coef) / 2);
        cube_screen_cords = {"up left": [Math.round(width / 2) - half_cube_size, Math.round(height / 2) - half_cube_size],
                            "up right": [Math.round(width / 2) + half_cube_size, Math.round(height / 2) - half_cube_size],
                            "down left": [Math.round(width / 2) - half_cube_size, Math.round(height / 2) + half_cube_size],
                            "down right": [Math.round(width / 2) + half_cube_size, Math.round(height / 2) + half_cube_size]};
    }

    function undefinedAudioCheck(side){
        // alert(side.slice(8, 17));
        if (side.slice(8, 17) == "undefined"){
            // alert("undefined");
            document.getElementById("playButton").disabled = true;
        } else {
            document.getElementById("playButton").disabled = false;
        }
    }

    function changeAudio(side){
        if (main_sound != "none"){
            if (main_sound.isPlaying){main_sound.stop();}
        }
        if (side == "front") {
            undefinedAudioCheck("{{ front_audio }}");
            main_sound = front_audio;
        }
        else if (side == "left"){
        undefinedAudioCheck("{{ left_audio }}");
        main_sound = left_audio;}
        else if (side == "right"){
        undefinedAudioCheck("{{ right_audio }}");
        main_sound = right_audio;}
        else if (side == "up"){
        undefinedAudioCheck("{{ up_audio }}");
        main_sound = up_audio;}
        else if (side == "down"){
        undefinedAudioCheck("{{ down_audio }}");
        main_sound = down_audio;}
        else {
            main_sound = "none";
        }
    }

    function buf_check(side, x, y, buffer_size){
        if (side == "up"){
            in_x = (x >= cube_screen_cords['up left'][0] && x <= cube_screen_cords['up right'][0]);
            y_buf_limit = cube_screen_cords["up left"][1] - (half_cube_size * buffer_size);
            in_y = (y >= y_buf_limit && y <= cube_screen_cords['up left'][1]);
            big_bufer = (in_x && in_y);

            left_limit = cube_screen_cords['up left'][0] + (half_cube_size * buffer_size);
            right_limit = cube_screen_cords['up right'][0]  - (half_cube_size * buffer_size);
            in_x = ((x >= left_limit && x <= right_limit));
            up_limit = cube_screen_cords["up left"][1];
            down_limit = (cube_screen_cords['up left'][1] + (half_cube_size * buffer_size));
            in_y = (y >=  up_limit && y <= down_limit);
            small_bufer =  (in_x && in_y);

            return big_bufer || small_bufer;
        }
        if (side == "down"){
            in_x = (x >= cube_screen_cords['up left'][0] && x <= cube_screen_cords['up right'][0]);
            up_limit = cube_screen_cords["down left"][1];
            down_limit = cube_screen_cords["down left"][1] + (half_cube_size * buffer_size);
            in_y = (y >= up_limit && y <= down_limit);
            big_bufer = (in_x && in_y);

            left_limit = cube_screen_cords['up left'][0] + (half_cube_size * buffer_size);
            right_limit = cube_screen_cords['up right'][0]  - (half_cube_size * buffer_size);
            in_x = (x >= left_limit && x <= right_limit);
            up_limit = cube_screen_cords["down left"][1] - (half_cube_size * buffer_size);
            down_limit = cube_screen_cords['down left'][1];
            in_y = (y >=  up_limit && y <= down_limit);
            small_bufer =  (in_x && in_y);
            return big_bufer || small_bufer;
        }
        if (side == "left"){
            left_limit = cube_screen_cords['up left'][0] - (half_cube_size * buffer_size);
            in_x = (x >=  left_limit && x <= cube_screen_cords['up left'][0]);
            in_y = (y >= cube_screen_cords["up left"][1] && y <= cube_screen_cords["down left"][1]);
            big_bufer = (in_x && in_y);

            left_limit = cube_screen_cords['up left'][0];
            right_limit = cube_screen_cords['up left'][0] + (half_cube_size * buffer_size);
            in_x = (x >= left_limit && x <= right_limit);
            up_limit = cube_screen_cords["up left"][1] + (half_cube_size * buffer_size);
            down_limit = cube_screen_cords['down left'][1] - (half_cube_size * buffer_size);
            in_y = (y >=  up_limit && y <= down_limit);
            small_bufer =  (in_x && in_y);
            return big_bufer || small_bufer;
        }
        if (side == "right"){
            right_limit = cube_screen_cords['up right'][0] + (half_cube_size * buffer_size);
            in_x = (x >= cube_screen_cords["up right"][0] && x <= right_limit);
            in_y = (y >= cube_screen_cords["up right"][1] && y <= cube_screen_cords["down right"][1]);
            big_bufer = (in_x && in_y);

            right_limit = cube_screen_cords['up right'][0];
            left_limit = cube_screen_cords['up right'][0] - (half_cube_size * buffer_size);
            in_x = (x >= left_limit && x <= right_limit);
            up_limit = cube_screen_cords["up right"][1] + (half_cube_size * buffer_size);
            down_limit = cube_screen_cords['down right'][1] - (half_cube_size * buffer_size);
            in_y = (y >=  up_limit && y <= down_limit);
            small_bufer =  (in_x && in_y);
            return big_bufer || small_bufer;
        }
    }

    function mouseListenerCubeRotation(e) {
        if (e.which == 1){
            mousex = e.clientX;
            mousey = e.clientY;
            // size of press zone 30%
            buffer_coef = 0.3

            if (buf_check("up", mousex, mousey, buffer_coef)){  // если пользователь нажал вверх
                if (angle_of_rotation_y == 0){  // и куб при этом стоял на месте
                    if (cube_sides_y[current_side_y] != "up"){  // если это не сторона up
                        angle_of_rotation_y = Math.PI * 0.5;  // крутимся
                        current_side_y = (current_side_y + 1) % 4;  // измененяем сторону
                        if (cube_sides_y[current_side_y] == "x side" && cube_sides_x[current_side_x] == "front"){
                            changeAudio("front");
                        }
                        if (cube_sides_y[current_side_y] == "x side" && cube_sides_x[current_side_x] == "left"){
                            changeAudio("left");
                        }
                        if (cube_sides_y[current_side_y] == "x side" && cube_sides_x[current_side_x] == "right"){
                            changeAudio("right");
                        }
                        if (cube_sides_y[current_side_y] == "up"){  // если уже на стороне up
                            changeSides("up", 90 * current_side_x);  // поворочиваем картинку на стороне up
                            changeAudio("up");  // меняем аудио на сторону up
                        }
                    }
                }
            }
            else if (buf_check("down", mousex, mousey, buffer_coef)){
                if (angle_of_rotation_y == 0){
                    if (cube_sides_y[current_side_y] != "down"){
                        angle_of_rotation_y = -Math.PI * 0.5;
                        current_side_y -= 1;
                        if (current_side_y == -1){current_side_y = 3};
                        if (cube_sides_y[current_side_y] == "x side" && cube_sides_x[current_side_x] == "front"){
                            changeAudio("front");
                        }
                        if (cube_sides_y[current_side_y] == "x side" && cube_sides_x[current_side_x] == "left"){
                            changeAudio("left");
                        }
                        if (cube_sides_y[current_side_y] == "x side" && cube_sides_x[current_side_x] == "right"){
                            changeAudio("right");
                        }
                        if (cube_sides_y[current_side_y] == "down"){
                            changeSides("down", 90 * current_side_x);
                            changeAudio("down");
                        }
                    }
                }
            }
            else if (buf_check("right", mousex, mousey, buffer_coef)){
                if (angle_of_rotation_x == 0){
                    if (cube_sides_x[current_side_x] != "right"){
                        if ((cube_sides_y[current_side_y] != "down") && (cube_sides_y[current_side_y] != "up")){
                            angle_of_rotation_x = -Math.PI * 0.5;
                            current_side_x = (current_side_x + 1) % 4;
                            if (cube_sides_y[current_side_y] == "x side"){
                                if (cube_sides_x[current_side_x] == "front"){
                                    changeAudio("front");
                                }
                                if (cube_sides_x[current_side_x] == "right"){
                                    changeAudio("right");
                                }
                            }
                        }
                    }
                }
            }
            else if (buf_check("left", mousex, mousey, buffer_coef)){
                if (angle_of_rotation_x == 0){
                    if (cube_sides_x[current_side_x] != "left"){
                        if ((cube_sides_y[current_side_y] != "down") && (cube_sides_y[current_side_y] != "up")){
                            angle_of_rotation_x = Math.PI * 0.5;
                            current_side_x -= 1;
                            if (current_side_x == -1){current_side_x = 3};
                            if (cube_sides_y[current_side_y] == "x side"){
                                if (cube_sides_x[current_side_x] == "front"){
                                    changeAudio("front");
                                }
                                if (cube_sides_x[current_side_x] == "left"){
                                    changeAudio("left");
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    function cubeRotation(){
        if (angle_of_rotation_x > 0){
            if (angle_of_rotation_x > speed_of_rotation_x) {
                cube.rotation.y += speed_of_rotation_x;
                angle_of_rotation_x -= speed_of_rotation_x;
            }
            else {
                cube.rotation.y += angle_of_rotation_x;
                angle_of_rotation_x = 0;
            }
        }
        if (angle_of_rotation_x < 0){
            if (angle_of_rotation_x < -speed_of_rotation_x){
                cube.rotation.y -= speed_of_rotation_x;
                angle_of_rotation_x += speed_of_rotation_x;
            } else {
                cube.rotation.y += angle_of_rotation_x;
                angle_of_rotation_x = 0;
            }
        }
        if (angle_of_rotation_y > 0){
            if (angle_of_rotation_y > speed_of_rotation_y) {
                cube.rotation.x += speed_of_rotation_y;
                angle_of_rotation_y -= speed_of_rotation_y;
            }
            else {
                cube.rotation.x += angle_of_rotation_y;
                angle_of_rotation_y = 0;
            }
        }
        if (angle_of_rotation_y < 0){
            if (angle_of_rotation_y < -speed_of_rotation_y){
                cube.rotation.x -= speed_of_rotation_y;
                angle_of_rotation_y += speed_of_rotation_y;
            } else {
                cube.rotation.x += angle_of_rotation_y;
                angle_of_rotation_y = 0;
            }
        }
    }

    function render() {
        requestAnimationFrame( render );
        cubeRotation();
        screenUpdateCheck();
        // debug();
    }

    function imageSideText(text, color){
        const cv = document.createElement( 'canvas' );
        cube_width = 1000
        cv.width = cube_width;
        cv.height = cube_width;
        ctx = cv.getContext( '2d' );
        ctx.fillStyle = '#fefefe';
        ctx.fillRect( 0, 0, cv.width, cv.height );

		if (hints_enabled){
    	    ctx = addTopGrd(ctx, cube_width, 50);
	        ctx = addBottomGrd(ctx, cube_width, 50);
	        ctx = addLeftGrd(ctx, cube_width, 50);
	    }
	    
        ctx.fillStyle = color;
        ctx.textAlign = "center";
        ctx.textBaseline = "top";

        symbol_size_const = 0.6;
        font_size = Math.round(cube_width / ((text.length + 1) * symbol_size_const));
        max_font_size = 150;
        if (font_size > max_font_size) {font_size = max_font_size;}
        ctx.font = 'bold ' + font_size + 'px Monospace';
        // // for (var i = 0; i < text_words.length; i++) {
        // //     line_num = (i + ((lines_number - text_words.length) / 2)) / lines_number;
        ctx.fillText(text, cube_width / 2, 0.825 * cube_width);

        new_image = document.getElementById("right_side_image");
        // console.log(new_image);
        up_indent = 0.1 * cube_width
        down_indent = 0.2 * cube_width
        left_indent = 0.15 * cube_width
        right_indent = 0.15 * cube_width
        // console.log(up_indent); // 100
        // console.log(left_indent); // 150
		// console.log(cube_width - down_indent - up_indent); // 800
		// console.log(cube_width - right_indent - left_indent); // 850
        ctx.drawImage( new_image, 
        			   left_indent, 
        			   up_indent, 
        			   cube_width - right_indent - left_indent, 
        			   cube_width - down_indent - up_indent);
        
        const cvTexture1 = new THREE.Texture( cv );
        cvTexture1.needsUpdate = true; // otherwise all black only
        return cvTexture1;
    }

    function audioInit(){
        var audioLoader = new THREE.AudioLoader();
        audioLoader.load( '{{ front_audio }}', function( buffer ) {
                front_audio.setBuffer( buffer );
                front_audio.setLoop(false);
                front_audio.setVolume(0.5);
            },
        );
        var audioLoader = new THREE.AudioLoader();
        audioLoader.load( '{{ left_audio }}', function( buffer ) {
                left_audio.setBuffer( buffer );
                left_audio.setLoop(false);
                left_audio.setVolume(0.5);
            },
        );
        var audioLoader = new THREE.AudioLoader();
        audioLoader.load( '{{ right_audio }}', function( buffer ) {
                right_audio.setBuffer( buffer );
                right_audio.setLoop(false);
                right_audio.setVolume(0.5);
            },
        );
        var audioLoader = new THREE.AudioLoader();
        audioLoader.load( '{{ up_audio }}', function( buffer ) {
                up_audio.setBuffer( buffer );
                up_audio.setLoop(false);
                up_audio.setVolume(0.5);
            },
        );
        var audioLoader = new THREE.AudioLoader();
        audioLoader.load( '{{ down_audio }}', function( buffer ) {
                down_audio.setBuffer( buffer );
                down_audio.setLoop(false);
                down_audio.setVolume(0.5);
            },
        );
        main_sound = front_audio;
        changeAudio("front");
    }

    if ({{ words_learn_state }}) {
    	trainer_button = document.getElementById("trainer-button");
    	trainer_button.hidden = false;
    }

    var hints_enabled = {{ hints_enabled }};

	function onHelpButtonClick(event){
		explanation_container = document.getElementById("explanation-container");
		explanation_container.hidden = !explanation_container.hidden;
		if (!explanation_container.hidden) {
			document.removeEventListener('mousedown', mouseListenerCubeRotation);
		} else {
			document.addEventListener('mousedown', mouseListenerCubeRotation);
		}
	}

	function onCloseButtonClick(event){
		explanation_container = document.getElementById("explanation-container");
		explanation_container.hidden = true;
		document.addEventListener('mousedown', mouseListenerCubeRotation);
	}

	document.getElementById("help-button").addEventListener("click", onHelpButtonClick, false)
	document.getElementById("close-button").addEventListener("click", onCloseButtonClick, false)

    document.addEventListener('mousedown', mouseListenerCubeRotation);

    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera( size_of_scene, window.innerWidth / window.innerHeight,
     start_of_scene_z, end_of_scene_z );  // camera perspective
    camera.position.z = camera_z;

    var renderer = new THREE.WebGLRenderer();
    renderer.setSize( window.innerWidth, window.innerHeight);  // cube lesson size on the screen
    document.body.appendChild( renderer.domElement);

    var geometry = new THREE.BoxGeometry( cube_scene_size, cube_scene_size, cube_scene_size );
    const loader = new THREE.TextureLoader();
    const img_loader = new THREE.ImageLoader();
    var front_text = "{{ hieroglyph }}";
    var left_text = "{{ phrase_ch }}";
    var right_text = "{{ transcription }}";
    var up_text = "{{ phrase_ru }}";
    var down_text = "{{ translation }}";
    var back_text = "";
    front_color = "#000000"
    left_color = "#006AFF"
    right_color = "#158903"
    up_color = "#FF660C"
    down_color = "#9C1313"
    back_color = "fefefe"
    var materials = [
        new THREE.MeshBasicMaterial({map: imageSideText(right_text, right_color)}),  // right
        new THREE.MeshBasicMaterial({map: cubeViewSideHieroglyphText(left_text,  0, left_color, "left")}),  // left
        new THREE.MeshBasicMaterial({map: cubeViewSideText(up_text,    0, up_color, "up")}),  // up
        new THREE.MeshBasicMaterial({map: cubeViewSideText(down_text,  0, down_color, "down")}),  // down
        new THREE.MeshBasicMaterial({map: cubeViewSideHieroglyphText(front_text, 0, front_color, "front")}),  // front
        new THREE.MeshBasicMaterial({map: cubeViewSideText(back_text,  0, back_color, "back")}),  // back
    ];
    cube = new THREE.Mesh(geometry, materials);
    cube.rotation.x = 0;
    cube.rotation.y = 0;
    cube.rotation.z = 0;
    scene.add( cube );
    
    var listener = new THREE.AudioListener();
    camera.add( listener );
    var front_audio = new THREE.Audio( listener );
    var left_audio = new THREE.Audio( listener );
    var right_audio = new THREE.Audio( listener );
    var up_audio = new THREE.Audio( listener );
    var down_audio = new THREE.Audio( listener );
    audioInit(camera);
    render();
</script>
</body>
</html>

